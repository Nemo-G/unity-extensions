# 开发经验文档

## 编写原则
- **通用性**: 避免游戏特定术语，经验应适用于各种游戏开发
- **简洁性**: 描述简洁明了，避免冗余，代码示例只保留关键部分

## 基本信息
- **创建日期**: 2026-02-25
- **相关任务**: Angry Birds 风格游戏开发
- **技术栈**: Unity 2D

## 问题描述

### 问题表现
在 Unity 2D 游戏中，实现了相机拖拽功能（CameraDrag）和可点击游戏对象（如 BirdController 使用 OnMouseDown/OnMouseDrag）。当点击游戏对象时，相机拖拽脚本拦截了鼠标事件，导致游戏对象的 OnMouseDown 无法触发，表现为点击游戏对象时拖动了相机而不是选中游戏对象。

### 触发条件
- 场景中同时存在相机拖拽脚本和可点击游戏对象
- 相机拖拽脚本在 Update 中直接检测 `Input.GetMouseButtonDown(0)` 而不判断点击目标
- 游戏对象使用 OnMouseDown 等鼠标事件函数

## 解决方案

### 关键步骤
1. 在相机拖拽脚本中添加射线检测，判断鼠标是否点击到可交互对象
2. 如果点击到可交互对象，则不启动相机拖拽
3. 使用 `Physics2D.Raycast` 检测点击目标

### 关键代码
```csharp
// CameraDrag.cs 中添加的方法
private bool IsClickingOnInteractive()
{
    Vector2 mouseWorldPos = mainCamera.ScreenToWorldPoint(Input.mousePosition);
    RaycastHit2D hit = Physics2D.Raycast(mouseWorldPos, Vector2.zero);
    
    if (hit.collider != null)
    {
        GameObject clickedObject = hit.collider.gameObject;
        
        // 检查是否点击到可交互组件
        if (clickedObject.GetComponent<BirdController>() != null) return true;
        if (clickedObject.GetComponent<PigHealth>() != null) return true;
        if (clickedObject.GetComponent<BlockHealth>() != null) return true;
    }
    return false;
}

// 在 HandleDragInput 中调用
if (Input.GetMouseButtonDown(0))
{
    if (IsClickingOnInteractive())
    {
        isDragging = false;
        isBlockedByUI = true;
        return;
    }
    // ... 正常拖拽逻辑
}
```

### 最终方案
在相机拖拽脚本的鼠标按下检测中，先通过 2D 射线检测判断点击目标。如果点击到带有特定组件（如 BirdController、PigHealth、BlockHealth）的游戏对象，则标记为"被 UI 阻塞"并跳过相机拖拽逻辑，让鼠标事件传递给游戏对象处理。

---
**文档版本**: v4.0
**维护者**: Experience Manager
**最后更新**: 2026-02-25
